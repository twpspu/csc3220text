<!DOCTYPE html><html>
<!-- Mirrored from web.mit.edu/6.813/www/sp18/classes/11-prototyping/ by HTTrack Website Copier/3.x [XR&CO'2014], Thu, 19 Dec 2019 22:01:40 GMT -->
<head>
<!--
  Character encoding note: This file should be saved and opened in UTF-8. If
  this is done correctly, then the following string should not be garbled in
  your editor (it should be rendered as shown in chartest.png):

  Character encoding test: «ÆØÅÉÈÑÜæøåéèñü¢~§'»
-->
<meta charset="UTF-8">

<!-- Lecture title entered here: -->
<title>Reading 11: Prototyping</title>  

<link href="../../web/handout-style.css" rel="stylesheet"><meta name="viewport" content="width=device-width, initial-scale=1"></head>
<body><header>CSC3220 Application Programming</a><div></div></header>
<nav class="table-of-contents col-sm-2"><ul class="nav"><li><a href="#reading_11_prototyping">Reading 11: Prototyping</a></li><li><a href="#prototyping">Prototyping</a></li><li><a href="#paper_prototypes">Paper Prototypes</a></li><li><a href="#computer_prototypes">Computer Prototypes</a></li></ul></nav>
<main class="container-fluid"><!--<iframe class="exercises-status" src="https://rcm.scripts.mit.edu/handx/sp18/status.php"></iframe>--><h1 class="handout-title col-sm-8 col-sm-offset-2" id="reading_11_prototyping">Reading 11: Prototyping</h1>

<div data-outline="reading_11_prototyping"><div class="markdown col-sm-8 col-sm-offset-2 converted"><div class="row"><div class="slide col-sm-6"><div class="slideTitle"><p>UI Hall of Fame or Shame?</p></div>
<table class="full-width"><tbody><tr><th style="width:50%"><p>Ghostview</p></th><th><p>Acrobat</p></th></tr>
<tr><td><img src="figures/01.png" style="padding-right: 10px"></td>
<td><img src="figures/03.png"></td></tr>
<tr><td><img src="figures/04.png"></td>
<td><img src="figures/02.png" style="width:60%"></td></tr></tbody></table></div>

<p>On the left is Ghostview, a Unix program that displays Postscript files. Ghostview has no scrollbar.  Instead, it scrolls by direct manipulation of the page image. Clicking and dragging the page downward moves the page image upward. That is, when you drag the mouse down, more of the page image come into view at the bottom of the window. Does this make sense? What mental model, or physical analogy, does this correspond to?</p>

<p>On the right is Acrobat, which displays PDF files. Acrobat has scrollbars, but you can also directly manipulate the page image, as in Ghostview - only now clicking and dragging downward moves the page downward, revealing more page image at the top of the window. What mental model does this correspond to?</p>

<p>What if you used both Acrobat and Ghostview frequently (one for PDF, say, and the other for Postscript)?</p>

<p>Which model does a smartphone use for scrolling, and which model do scrollbars and mouse scrollwheels use?</p></div>

<div class="row"><div class="slide col-sm-6"><div class="slideTitle"><p>UI Hall of Fame or Shame?</p></div>
<table style="line-height: 120%"><tbody><tr><th style="text-align: center"><p>Xerox Star scrollbar</p></th>
<th style="text-align: center"><p>Original Macintosh scrollbar</p></th>
<th style="text-align: center"><p>Current Macintosh scrollbar</p></th></tr>
<tr><td><img src="figures/05.png" style="height: 200px"></td>
<td><img src="figures/06.png" style="height: 200px"></td>
<td><img src="figures/07.png" style="height:200px"></td></tr></tbody></table></div>

<p>Let’s look at scrolling some more. Scrollbars have evolved considerably over the history of graphical user interfaces.</p>

<p>The Xerox Star offered the earliest incarnation of a graphical user interface, and its scrollbar already had many of the features we recognize in modern scrollbars, such as a <strong>track</strong> containing a scrollbar <strong>thumb</strong> (the handle that you can drag up and down). Even its arrow buttons do the same thing - e.g., pushing on the top button makes more of the page appear at the top of the window, just like the modern scrollbar. But they’re labeled the opposite way - the top button has a down arrow on it. Why is that? What mental model would lead you to call that button down? Is that consistent with the mental model of the scrollbar thumb?</p>

<p>Another interesting difference between the Star scrollbar and modern scrollbars are the - and + buttons, which move by whole pages. This functionality hasn’t been eliminated from the modern scrollbar; instead, the modern scrollbar just drops the obvious affordance for it. You can still click on the track above or below the thumb in order to jump by whole pages.
What else has changed in modern scrollbars?</p></div>

<h2 id="prototyping">Prototyping</h2>

<div data-outline="prototyping"><div class="row"><p>Today we’re going to talk about protototyping: producing cheaper, less accurate renditions of your target interface. Prototyping is essential in the early iterations of a spiral design process, and it’s useful in later iterations too.</p></div><div class="row"><div class="slide col-sm-6"><div class="slideTitle"><p>Why Prototype?</p></div>
<ul><li><p>Get feedback earlier, cheaper</p></li>
<li><p>Experiment with alternatives</p></li>
<li><p>Easier to change or throw away</p></li></ul></div>

<p>We build prototypes for several reasons, all of which largely boil down to cost.
First, prototypes are much faster to build than finished implementations, so we can evaluate them sooner and get early feedback about the good and bad points of a design.
Second, if we have a design decision that is hard to resolve, we can build multiple prototypes embodying the different alternatives of the decision.</p>

<p>Third, if we discover problems in the design, a prototype can be changed more easily, for the same reasons it could be built faster. Prototypes are more malleable. Most important, if the design flaws are serious, a prototype can be <strong>thrown away</strong>. It’s important not to commit strongly to design ideas in the early stages of design. Unfortunately, writing and debugging a lot of code creates a psychological sense of commitment which is hard to break. You don’t want to throw away something you’ve worked hard on, so you’re tempted to keep some of the code around, even if it really should be scrapped. (Alan Cooper, <a href="http://www.cooper.com/journal/2008/5/the_perils_of_prototyping">“The Perils of Prototyping”</a>, 1994. )</p>

<p>Most of the prototyping techniques we’ll see in this reading actually force you to throw the prototype away. For example, a paper mockup won’t form any part of a finished software implementation. This is a good mindset to have in early iterations, since it maximizes your creative freedom.</p></div><div class="row"><div class="slide col-sm-6"><div class="slideTitle"><p>Prototype Fidelity</p></div>
<ul><li><p>Low fidelity: omits details</p></li>
<li><p>High fidelity: more like finished product</p></li></ul></div>

<p>An essential property of a prototyping technique is its <strong>fidelity</strong>, which is simply how similar it is to the finished interface. Low-fidelity prototypes omit details, use cheaper materials, or use different interaction techniques. High-fidelity prototypes are very similar to the finished product.</p></div><div class="row"><div class="slide col-sm-6"><div class="slideTitle"><p>Fidelity is Multidimensional</p></div>
<ul><li><p>Breadth: % of features covered</p>

<ul><li><p>Only enough features for certain tasks</p></li></ul></li>
<li><p>Depth: degree of functionality</p>

<ul><li><p>Limited choices, canned responses, no error handling</p></li></ul></li></ul>

<img src="figures/09.png"></div>

<p>Fidelity is not just one-dimensional, however. Prototypes can be low- or high-fidelity in various different ways (Carolyn Snyder, <em>Paper Prototyping</em>, 2003).</p>

<p><strong>Breadth</strong> refers to the fraction of the feature set represented by the prototype. A prototype that is low-fidelity in breadth might be missing many features, having only enough to accomplish certain specific tasks. A word processor prototype might omit printing and spell-checking, for example.</p>

<p><strong>Depth</strong> refers to how deeply each feature is actually implemented. Is there a backend behind the prototype that’s actually implementing the feature? Low-fidelity in depth may mean limited choices (e.g., you can’t print double-sided), canned responses (always prints the same text, not what you actually typed), or lack of robustness and error handling (crashes if the printer is offline).</p>

<p>A diagrammatic way to visualize breadth and depth is shown (following Nielsen, <em>Usability Engineering</em>, p. 94). A <strong>horizontal prototype</strong> is all breadth, and little depth; it’s basically a frontend with no backend. A <strong>vertical prototype</strong> is the converse: one area of the interface is implemented deeply. The question of whether to build a horizontal or vertical prototype depends on what risks you’re trying to mitigate. In user interface design, horizontal prototypes are more common, since they address usability risk. But if some aspect of the application is a risky implementation - you’re not sure if it can be implemented to meet the requirements - then you may want to build a vertical prototype to test that.
A special case lies at the intersection of a horizontal and a vertical prototype. A <strong>scenario</strong> shows how the frontend would look for a single concrete task.</p></div><div class="row"><div class="slide col-sm-6"><div class="slideTitle"><p>More Dimensions of Fidelity</p></div>

<ul><li><p>Look: appearance, graphic design</p>

<ul><li><p>Sketchy, hand-drawn</p></li></ul></li>
<li><p>Feel: input method</p>

<ul><li><p>Pointing &amp; writing feels very different from mouse &amp; keyboard</p></li></ul></li></ul></div>

<p>Two more crucial dimensions of a prototype’s fidelity are, loosely, its look and its feel. <strong>Look</strong> is the appearance of the prototype. A hand-sketched prototype is low-fidelity in look, compared to a prototype that uses the same widget set as the finished implementation. <strong>Feel</strong> refers to the physical methods by which the user interacts with the prototype. A user interacts with a paper mockup by pointing at things to represent mouse clicks, and writing on the paper to represent keyboard input. This is a low-fidelity feel for a desktop application (but it may not be far off for a tablet PC application).</p></div><div class="row"><div class="slide col-sm-6"><div class="slideTitle"><p>Comparing Fidelity of Look &amp; Feel</p></div>
<img src="figures/11.png">
<img src="figures/12.png"></div>

<p>Here’s the same dialog box in both low-fi and high-fi versions. How do they differ in the kinds of things you can test and get feedback about?</p></div></div>











<h2 id="paper_prototypes">Paper Prototypes</h2>

<div data-outline="paper_prototypes"><div class="row"><div class="slide col-sm-6"><div class="slideTitle"><p>Paper Prototype</p></div>

<ul><li><p>Interactive paper mockup</p>

<ul><li><p>Sketches of screen appearance</p></li>
<li><p>Paper pieces show windows, menus, dialog boxes</p></li></ul></li>
<li><p>Interaction is natural</p>

<ul><li><p>Pointing with a finger = mouse click</p></li>
<li><p>Writing = typing</p></li></ul></li>
<li><p>A person simulates the computer’s operation</p>

<ul><li><p>Putting down &amp; picking up pieces</p></li>
<li><p>Writing responses on the “screen”</p></li>
<li><p>Describing effects that are hard to show on paper</p></li></ul></li>
<li><p>Low fidelity in look &amp; feel</p></li>
<li><p>High fidelity in depth (person simulates the backend)</p></li></ul></div>

<p><strong>Paper prototypes</strong> are an excellent choice for early design iterations. A paper prototype is a physical mockup of the interface, mostly made of paper. It’s usually hand-sketched on mutiple pieces, with different pieces showing different menus, dialog boxes, or window elements.</p>

<p>The key difference between mere sketches and a paper prototype is <strong>interactivity</strong>. A paper prototype is brought to life by a design team member who simulates what the computer would do in response to the user’s “clicks” and “keystrokes”, by rearranging pieces, writing custom responses, and occasionally announcing some effects verbally that are too hard to show on paper. Because a paper prototype is actually interactive, you can actually user-test it: give users a task to do and watch how they do it.</p>

<p>A paper prototype is clearly low fidelity in both look and feel. But it can be arbitrarily high fidelity in breadth at very little cost (just sketching, which is part of design anyway). Best of all, paper prototypes can be <strong>high-fidelity in depth</strong> at little cost, since a human being is simulating the backend.</p>

<p>Much of the material about paper prototyping in this reading draws on the classic paper by Rettig et al, <a href="http://www.basilsafwat.com/references/Prototyping for Tiny Fingers.pdf">“Prototyping for tiny fingers”</a> (CACM 1994), and Carolyn Snyder’s book <em>Paper Prototyping: The Fast and Easy Way to Design and Refine User Interfaces</em> (Morgan Kaufmann, 2003).</p></div><div class="row"><div class="slide col-sm-6"><div class="slideTitle"><p>Why Paper Prototyping?</p></div>

<ul><li><p>Faster to build</p>

<ul><li><p>Sketching is faster than programming</p></li></ul></li>
<li><p>Easier to change</p>

<ul><li><p>Easy to make changes between user tests, or even <em></em></p><p><em>during</em></p> a user test<p></p></li>
<li><p>No code investment - everything will be thrown away (except the design)</p></li></ul></li>
<li><p>Focuses attention on big picture</p>

<ul><li><p>Designer doesn’t waste time on details</p></li>
<li><p>Customer makes more creative suggestions, not nitpicking</p></li></ul></li>
<li><p>Nonprogrammers can help</p>

<ul><li><p>Only kindergarten skills are required</p></li></ul></li></ul></div>

<p>But why use paper? And why hand sketching rather than a clean drawing from a drawing program?</p>

<p>Hand-sketching on paper is faster. You can draw many sketches in the same time it would take to draw one user interface with code. For most people, hand-sketching is also faster than using a drawing program to create the sketch.</p>

<p>Paper is easy to change. You can even change it during user testing. If part of the prototype was a problem for one user, you can scratch it out or replace it before the next user arrives. Surprisingly, paper is more malleable than digital bits in many ways.</p>

<p>Hand-sketched prototypes in particular are valuable because they focus attention on the issues that matter in early design without distracting anybody with details. When you’re sketching by hand, you aren’t bothered with details like font, color, alignment, whitespace, etc. In a drawing program, you would be faced with all these decisions, and you might spend a lot of time on them - time that would clearly be wasted if you have to throw away this design. Hand sketching also improves the feedback you get from users. They’re less likely to nitpick about details that aren’t relevant at this stage. They won’t complain about the color scheme if there isn’t one. More important, however, a hand-sketch design seems less finished, less set in stone, and more open to suggestions and improvements. Architects have known about this phenomenon for many years. If they show clean CAD drawings to their clients in the early design discussions, the clients are less able to discuss needs and requirements that may require radical changes in the design. In fact, many CAD tools have an option for rendering drawings with a “sketchy” look for precisely this reason.</p>

<p>A final advantage of paper prototyping: no special skills are required. So graphic designers, usability specialists, and even users can help create prototypes and operate them.</p></div><div class="row"><div class="slide col-sm-6"><div class="slideTitle"><p>Tools for Paper Prototyping</p></div>

<ul><li><p>White poster board (11”x14”)</p>

<ul><li><p>For background, window frame</p></li></ul></li>
<li><p>Big (unlined) index cards (4”x6”, 5”x8”)</p>

<ul><li><p>For menus, window contents, and dialog boxes</p></li></ul></li>
<li><p>Restickable glue</p>

<ul><li><p>For keeping pieces fixed</p></li></ul></li>
<li><p>White correction tape</p>

<ul><li><p>For text fields, checkboxes, short messages</p></li></ul></li>
<li><p>Overhead transparencies</p>

<ul><li><p>For highlighting, user “typing”</p></li></ul></li>
<li><p>Photocopier</p>

<ul><li><p>For making multiple blanks</p></li></ul></li>
<li><p>Pens &amp; markers, scissors, tape</p></li></ul></div>

<p>Here are the elements of a paper prototyping toolkit.</p>

<p>Although standard (unlined) paper works fine, you’ll get better results from sturdier products like <strong>poster board</strong> and <strong>index cards</strong>. Use poster board to draw a static background, usually a window frame. Then use index cards for the pieces you’ll place on top of this background. You can cut the index cards down to size for menus and window internals.</p>

<p><strong>Restickable Post-it Note glue</strong>, which comes in a roll-on stick, is a must. This glue lets you make all of your pieces sticky, so they stay where you put them.</p>

<p><strong>Post-it correction tape</strong> is another useful tool. It’s a roll of white tape with Post-it glue on one side. Correction tape is used for text fields, so that users can write on the prototype without changing it permanently. You peel off a length of tape, stick it on your prototype, let the user write into it, and then peel it off and throw it away. Correction tape comes in two widths, “2 line” and “6 line”. The 2-line width is good for single-line text fields, and the 6-line width for text areas.</p>

<p><strong>Overhead transparencies</strong> are useful for two purposes. First, you can make a selection highlighted by cutting a piece of transparency to size and coloring it with a transparency marker. Second, when you have a form with several text fields in it, it’s easier to just lay a transparency over the form and let the users write on that, rather than sticking a piece of correction tape in every field.</p>

<p>If you have many similar elements in your prototype, a <strong>photocopier</strong> can save you time.</p>

<p>And, of course, the usual kindergarten equipment: pens, markers, scissors, tape.</p></div><div class="row"><div class="slide col-sm-6"><div class="slideTitle"><p>Tips for Good Paper Prototypes</p></div>

<ul><li><p>Make it larger than life</p></li>
<li><p>Make it monochrome</p></li>
<li><p>Replace tricky visual feedback with audible descriptions</p>

<ul><li><p>Tooltips, drag &amp; drop, animation, progress bar</p></li></ul></li>
<li><p>Keep pieces organized</p>

<ul><li><p>Use folders &amp; open envelopes</p></li></ul></li></ul></div>

<p>A paper prototype should be larger than life-size. Remember that fingers are bigger than a mouse pointer, and people usually write bigger than 12 point. So it’ll be easier to use your paper prototype if you scale it up a bit. It will also be easier to see from a distance, which is important because the prototype lies on the table, and because when you’re testing users, there may be several observers taking notes who need to see what’s going on. <strong>Big is good.</strong></p>

<p>Don’t worry too much about color in your prototype. Use a single color. It’s simpler, and it won’t distract attention from the important issues.</p>

<p>You don’t have to render every visual effect in paper. Some things are just easier to say aloud: “the basketball is spinning.” “A progress bar pops up: 20%, 50%, 75%, done.” If your design supports tooltips, you can tell your users just to point at something and ask “What’s this?”, and you’ll tell them what the tooltip would say. But if you actually want to test the tooltip messages you should prototype them on paper.</p>

<p>Figure out a good scheme for organizing the little pieces of your prototype. One approach is a three-ring binder, with different screens on different pages. Most interfaces are not sequential, however, so a linear organization may be too simple. Two-pocket folders are good for storing big pieces, and letter envelopes (with the flap open) are quite handy for keeping menus.</p></div><div class="row"><div class="slide col-sm-6"><div class="slideTitle"><p>Hand-Drawn or Not?</p></div>
<img src="figures/13.jpg">
<img src="figures/14.jpg">
<img src="figures/15.jpg"></div>

<p>Here are some of the prototypes made by an earlier class. Should a paper prototype be hand-sketched or computer-drawn? Generally hand-sketching is better in early design, but sometimes realistic images can be constructive additions.</p>

<p>The first image is a prototype for an interface that will be integrated into an existing program (Eclipse), so the prototype is mostly constructed of modified Eclipse screenshots. The result is very clean and crisp, but also tiny - it’s hard to read from a distance. It may also be harder for a test user to focus on commenting about the new parts of the interface, since the new features look just like Eclipse. A hybrid hand-sketched/screenshot interface might work even better.</p>

<p>The second image shows such a hybrid – an interface designed to integrate into a web browser. Actual screenshots of web pages are used, mainly as props, to make the prototype more concrete and help the user visualize the interface better. Since web page layout isn’t the problem the interface is trying to solve, there’s no reason to hand-sketch a web page.</p>

<p>The third image shows a pure hand-sketched interface that might have benefited from such props – a photo organizer could use real photographs to help the user think about what kinds of things they need to do with photographs. This prototype could also use a <strong>window frame</strong> - a big posterboard to serve as a static background.</p></div><div class="row"><div class="slide col-sm-6"><div class="slideTitle"><p>Size Matters</p></div>
<img src="figures/16.jpg">
<img src="figures/17.jpg"></div>

<p>Both of these prototypes have good window frames, but the big one is easier to read and manipulate.</p></div><div class="row"><div class="slide col-sm-6"><div class="slideTitle"><p>The Importance of Writing Big and Dark</p></div>
<img src="figures/18.jpg"></div>

<p>This prototype is even easier to read. Markers are better than pencil. (Whiteout and correction tape can fix mistakes as well as erasers can!) Color is also neat, but don’t bother unless color is a design decision that needs to be tested, as it is in this prototype. If color doesn’t really matter, monochromatic prototypes work just as well.</p></div><div class="row"><div class="slide col-sm-6"><div class="slideTitle"><p>Post-it Glue and Transparencies are Good</p></div>
<img src="figures/19.jpg">
<img src="figures/20.jpg"></div>

<p>The first prototype here has lots of little pieces that have trouble staying put. Post-it glue can help with that.</p>

<p>The second prototype is completely covered with a transparency. Users can write on it directly with dry-erase marker, which just wipes off - a much better approach than water-soluble transparency markers. With multiple layers of transparency, you can let the user write on the top layer, while you use a lower layer for computer messages, selection highlighting, and other effects.</p></div><div class="row"><div class="slide col-sm-6"><div class="slideTitle"><p>Paper Allows Cheap Exploration</p></div>
<img src="figures/21.jpg"></div>

<p>Paper is great for prototyping features that would be difficult to implement. This project (a contact manager) originally envisioned showing your social network as a graph, but when they prototyped it, it turned out that it wasn’t too useful. The cost of trying that feature on paper was trivial, so it was easy to throw it away. Trying it in code, however, would have taken much longer, and been much harder to discard.</p></div><div class="row"><div class="slide col-sm-6"><div class="slideTitle"><p>Low-Fidelity Prototypes Aren’t Always Paper</p></div>
<img src="figures/22.png">
<img src="figures/23.png"></div>

<p>The spirit of low-fidelity prototyping is really about using cheap physical objects to simulate software. Paper makes sense for desktop and web UIs because they’re flat. But other kinds of UI prototypes might use different materials. Jeff Hawkins carried a block of wood (not this one, but similar) around in his pocket as a prototype for the first PalmPilot. (<a href="http://www.designinginteractions.com/interviews/JeffHawkins">Interview here</a>)</p></div><div class="row"><div class="slide col-sm-6"><div class="slideTitle"><p>Multiple Alternatives Generate Better Feedback</p></div>
<img src="figures/24.png">
<img src="figures/25.png">
<img src="figures/26.png"></div>

<p>Doing several prototypes and presenting them to the same user is a great idea. When a design is presented with others, people tend to be <strong>more ready to criticize</strong> and offer problems, which is exactly what you want in the early stages of design. These three paper prototypes of a house thermostat were tested against users both singly and as a group of three, and it was found that people offered fewer positive comments when they saw the designs together than when they saw them alone.</p>

<p>Pictures from Tohidi, Buxton, Baecker, Sellen. “Getting the Right Design and the Design Right: Testing Many Is Better Than One.” <em>CHI 2006</em>.</p></div><div class="row"><div class="slide col-sm-6"><div class="slideTitle"><p>How to Test a Paper Prototype</p></div>

<ul><li><p>Roles for design team</p>

<ul><li><p>Computer
 </p><ul><li><p>Simulates prototype</p></li>
 <li><p>Doesn’t give any feedback that the computer wouldn’t</p></li></ul><p></p></li>

<li><p>Facilitator</p><ul><li><p>Presents interface and tasks to the user</p></li>
 <li><p>Encourages user to “think aloud” by asking questions</p></li>
 <li><p>Keeps user test from getting off track</p></li></ul><p></p></li>
<li><p>Observer</p><ul><li><p>Keeps mouth shut, sits on hands if necessary</p></li>
 <li><p>Takes copious notes</p></li></ul><p></p></li></ul></li></ul></div>

<p>Once you’ve built your prototype, you can put it in front of users and watch how they use it. We’ll see much more about user testing in a later class, including ethical issues. But here’s a quick discussion of user testing in the paper prototyping domain.</p>

<p>There are three roles for your design team to fill:</p>

<ol>
<li><p>The <strong>computer</strong> is the person responsible for making the prototype come alive. This person moves around the pieces, writes down responses, and generally does everything that a real computer would do. In particular, the computer should not do anything that a real computer wouldn’t. Think mechanically, and respond mechanically.</p></li>
<li><p>The <strong>facilitator</strong> is the human voice of the design team and the director of the testing session. The facilitator explains the purpose and process of the user study, obtains the user’s informed consent, and presents the user study tasks one by one. While the user is working on a task, the facilitator tries to elicit verbal feedback from the user, particularly encouraging the user to “think aloud” by asking probing (but not leading) questions. The facilitator is responsible for keeping everybody disciplined and the user test on the right track.</p></li>
<li><p>Everybody else in the room (aside from the user) is an <strong>observer</strong>. The most important rule about being an observer is to keep your mouth shut and watch. Don’t offer help to the user, even if they’re missing something obvious. Bite your tongue, sit on your hands, and just watch. The observers are the primary note takers, since the computer and the facilitator are usually too busy with their duties.</p></li>
</ol></div><div class="row"><div class="slide col-sm-6"><div class="slideTitle"><p>What You Can Learn from a Paper Prototype</p></div>

<ul><li><p>Conceptual model</p>

<ul><li><p>Do users understand it?</p></li></ul></li>
<li><p>Functionality</p>

<ul><li><p>Does it do what’s needed? Missing features?</p></li></ul></li>
<li><p>Navigation &amp; task flow</p>

<ul><li><p>Can users find their way around?</p></li>
<li><p>Are information preconditions met? </p></li></ul></li>
<li><p>Terminology</p>

<ul><li><p>Do users understand labels?</p></li></ul></li>
<li><p>Screen contents</p>

<ul><li><p>What needs to go on the screen?</p></li></ul></li></ul></div>

<p>Paper prototypes can reveal many usability problems that are important to find in early stages of design. Fixing some of these problems require large changes in design. If users don’t understand the metaphor or conceptual model of the interface, for example, the entire interface may need to be scrapped.</p></div><div class="row"><div class="slide col-sm-6"><div class="slideTitle"><p>What You Can’t Learn</p></div>

<ul><li><p>Look: color, font, whitespace, etc</p></li>
<li><p>Feel: efficiency issues</p></li>
<li><p>Response time</p></li>
<li><p>Are small changes noticed?</p>

<ul><li><p>Even the tiniest change to a paper prototype is clearly visible to user</p></li></ul></li>
<li><p>Exploration vs. deliberation</p>

<ul><li><p>Users are more deliberate with a paper prototype; they don’t explore or thrash as much</p></li></ul></li></ul></div>

<p>But paper prototypes don’t reveal every usability problem, because they are low-fidelity in several dimensions. Obviously, graphic design issues that depend on a high-fidelity <strong>look</strong> will not be discovered. Similarly, interaction issues that depend on a high-fidelity <strong>feel</strong> will also be missed. For example, problems like buttons that are too small, too close together, or too far away will not be detected in a paper prototype. The human computer of a paper prototype rarely reflects the speed of an implemented backend, so issues of <strong>response time</strong> - whether feedback appears quickly enough, or whether an entire task can be completed within a certain time constraint – can’t be tested either.</p>

<p>Paper prototypes don’t help answer questions about whether subtle feedback will even be noticed. Will users notice that message down in the status bar, or the cursor change, or the highlight change? In the paper prototype, even the tiniest change is grossly visible, because a person’s arm has to reach over the prototype and make the change. (If many changes happen at once, of course, then some of them may be overlooked even in a paper prototype. This is related to an interesting cognitive phenomenon called <strong>change blindness</strong>.)</p>

<p>There’s an interesting qualitative distinction between the way users use paper prototypes and the way they use real interfaces. Experienced paper prototypers report that users are more deliberate with a paper prototype, apparently thinking more carefully about their actions. This may be partly due to the simulated computer’s slow response; it may also be partly a social response, conscientiously trying to save the person doing the simulating from a lot of tedious and unnecessary paper shuffling. More deliberate users make fewer mistakes, which is bad, because you want to see the mistakes. Users are also less likely to randomly explore a paper prototype.</p>

<p>These drawbacks don’t invalidate paper prototyping as a technique, but you should be aware of them. Several studies have shown that low-fidelity prototypes identify substantially the same usability problems as high-fidelity prototypes (Virzi, Sokolov, &amp; Karis, <a href="https://www.researchgate.net/profile/Demetrios_Karis/publication/221519756_Usability_Problem_Identification_Using_Both_Low-_and_High-Fidelity_Prototypes/links/56baa93108ae3af6847d8bc9.pdf">“Usability problem identification using both low- and hi-fidelity prototypes”</a>, CHI ‘96; Catani &amp; Biers, “Usability evaluation and prototype fidelity”, Human Factors &amp; Ergonomics 1998).</p>

<div class="reading-exercises exercises panel-group converted" id="ex"><h4 class="text-danger">reading exercises</h4>

<div class="panel panel-danger"><div class="panel-heading" data-target="#ex-exercise" data-toggle="collapse"><span class="panel-title">Exercise (Self Study)</span></div><div class="panel-collapse collapse exercise-panel" id="ex-exercise" data-outline="exercise" data-ex-id="paper_prototypes/exercise" data-ex-category="reading-exercises" data-ex-remote="https://rcm.scripts.mit.edu/handx/sp18/submit.php" data-ex-handout="classes-11-prototyping"><div class="panel-body"><p>Which of the following statements are likely to be true about a paper prototype? (choose all good answers)</p><div class="form-group exercise-part" data-outline="a"><div class="checkbox exercise-choice" data-outline="Low fidelity in breadth means that only a couple of tasks are implemented in the prototype"><label for="md_converted_choice_1_0"><input type="checkbox" id="md_converted_choice_1_0">Low fidelity in breadth means that only a couple of tasks are implemented in the prototype</label><span class="exercise-answer exercise-remote" style="display: none;">(missing answer)</span></div>
<div class="checkbox exercise-choice" data-outline="Low fidelity in look means you can change the prototype by hand sketching"><label for="md_converted_choice_1_1"><input type="checkbox" id="md_converted_choice_1_1">Low fidelity in look means you can change the prototype by hand sketching</label><span class="exercise-answer exercise-remote" style="display: none;">(missing answer)</span></div>
<div class="checkbox exercise-choice" data-outline="High fidelity in feel means you can measure efficiency accurately"><label for="md_converted_choice_1_2"><input type="checkbox" id="md_converted_choice_1_2">High fidelity in feel means you can measure efficiency accurately</label><span class="exercise-answer exercise-remote" style="display: none;">(missing answer)</span></div>
<div class="checkbox exercise-choice" data-outline="Medium fidelity in depth means that a human is simulating the backend"><label for="md_converted_choice_1_3"><input type="checkbox" id="md_converted_choice_1_3">Medium fidelity in depth means that a human is simulating the backend</label><span class="exercise-answer exercise-remote" style="display: none;">(missing answer)</span></div>
</div><div class="exercise-explain exercise-remote"><p>(missing explanation)</p></div><div class="form-inline"><div class="form-group"><button class="btn hidden btn-default exercise-submit">check</button> <button class="btn btn-default exercise-reveal" style="display: none;">explain</button></div><div class="exercise-progress progress"><div class="progress-bar progress-bar-danger progress-bar-striped active"></div></div><div class="exercise-error"></div></div></div></div></div>



</div></div></div>



























<h2 id="computer_prototypes">Computer Prototypes</h2>

<div data-outline="computer_prototypes"><div class="row"><div class="slide col-sm-6"><div class="slideTitle"><p>Computer Prototype</p></div>

<ul><li><p>Interactive software simulation</p></li>
<li><p>High-fidelity in look &amp; feel</p></li>
<li><p>Low-fidelity in depth</p>

<ul><li><p>Paper prototype had a human simulating the backend; computer prototype doesn’t</p></li>
<li><p>Computer prototype may be <strong>horizontal</strong>: covers most features, but no backend</p></li></ul></li></ul></div>

<p>So at some point we have to depart from paper and move our prototypes into software. A typical computer prototype is a <strong>horizontal</strong> prototype. It’s high-fi in look and feel, but low-fi in depth - there’s no backend behind it. Where a human being simulating a paper prototype can generate new content on the fly in response to unexpected user actions, a computer prototype cannot.</p></div><div class="row"><div class="slide col-sm-6"><div class="slideTitle"><p>What You Can Learn From Computer Prototypes</p></div>

<ul><li><p>Everything you learn from a paper prototype, plus:</p></li>
<li><p>Screen layout</p>

<ul><li><p>Is it clear, overwhelming, distracting, complicated?</p></li>
<li><p>Can users find important elements?</p></li></ul></li>
<li><p>Colors, fonts, icons, other elements</p>

<ul><li><p>Well-chosen?</p></li></ul></li>
<li><p>Interactive feedback</p>

<ul><li><p>Do users notice &amp; respond to status bar messages, cursor changes, other feedback</p></li></ul></li>
<li><p>Efficiency issues</p>

<ul><li><p>Controls big enough? Too close together? Scrolling list is too long?</p></li></ul></li></ul></div>

<p>Computer prototypes help us get a handle on the graphic design and dynamic feedback of the interface.</p></div><div class="row"><div class="slide col-sm-6"><div class="slideTitle"><p>Why Use Prototyping Tools?</p></div>

 <ul><li><p>Faster than coding</p></li>
 <li><p>No debugging</p></li>
 <li><p>Easier to change or throw away</p></li>
 <li><p>Don’t let your UI toolkit do your graphic design</p></li></ul></div>

<p>One way to build a computer prototype is just to program it directly in an implementation language, like Java or C++, using a user interface toolkit, like Swing or MFC. If you don’t hook in a backend, or use stubs instead of your real backend, then you’ve got a horizontal prototype.</p>

<p>But it’s often better to use a <strong>prototyping tool</strong> instead. Building an interface with a tool is usually faster than direct coding, and there’s no code to debug. It’s easier to change it, or even throw it away if your design turns out to be wrong. Recall Cooper’s concerns about prototyping: your computer prototype may become so elaborate and precious that it becomes your final implementation, even though (from a software engineering point of view) it might be sloppily designed and unmaintainable.</p>

<p>Also, when you go directly from paper prototype to code, there’s a tendency to let your UI toolkit handle all the graphic design for you. That’s a mistake. For example, Java has layout managers that automatically arrange the components of an interface. Layout managers are powerful tools, but they produce horrible interfaces when casually or lazily used. A prototyping tool will help you envision your interface and get its graphic design right first, so that later when you move to code, you know what you’re trying to persuade the layout manager to produce.</p>

<p>Even with a prototyping tool, computer prototypes can still be a tremendous amount of work. When drag &amp; drop was being considered for Microsoft Excel, a couple of Microsoft summer interns were assigned to develop a prototype of the feature using Visual Basic. They found that they had to implement a substantial amount of basic spreadsheet functionality just to test drag &amp; drop. It took two interns their entire summer to build the prototype that proved that drag &amp; drop was useful. Actually adding the feature to Excel took a staff programmer only a week. This isn’t a fair comparison, of course - maybe six intern-months was a cost worth paying to mitigate the risk of one fulltimer-week, and the interns certainly learned a lot. But building a computer prototype can be a slippery slope, so don’t let it suck you in too deeply. Focus on what you want to test, i.e., the design risk you need to mitigate, and only prototype that.</p></div><div class="row"><div class="slide col-sm-6"><div class="slideTitle"><p>Computer Prototyping Techniques</p></div>

<ul><li><p>Storyboard</p>

<ul><li><p>Sequence of painted screenshots </p></li>
<li><p>Sometimes connected by hyperlinks (“hotspots”)</p></li></ul></li>
<li><p>Form builder</p>

<ul><li><p>Real windows assembled from a palette of widgets (buttons, text fields, labels, etc.)</p></li></ul></li>
<li><p>Wizard of Oz</p>

<ul><li><p>Computer frontend, human backend</p></li></ul></li></ul></div>

<p>There are two major techniques for building a computer prototype.</p>

<p>A <strong>storyboard</strong> is a sequence (a graph, really) of fixed screens. Each screen has one or more <strong>hotspots</strong> that you can click on to jump to another screen. Sometimes the transitions between screens also involve some animation in order to show a dynamic effect, like mouse-over feedback or drag-drop feedback.</p>

<p>A <strong>form builder</strong> is a tool for drawing real, working interfaces by dragging widgets from a palette and positioning them on a window.</p>

<p>A <strong>Wizard of Oz</strong> prototype is a kind of hybrid of a computer prototype and a paper prototype; the user interacts with a computer, but there’s a human behind the scenes figuring out how the user interface should respond.</p></div><div class="row"><div class="slide col-sm-6"><div class="slideTitle"><p>Storyboarding Tools</p></div>

<ul><li><p>Photoshop</p></li>
<li><p>Balsamiq Mockup</p></li>
<li><p>Mockingbird</p></li></ul>
<img src="figures/27.png"></div>

<p>Photoshop is classically used for storyboarding (also called “wireframe” prototypes), but here are some other tools that are increasing in popularity. Balsamiq Mockup and Mockingbird each offer a drawing canvas and a palette of graphical objects that look like widgets that can be dragged onto it. These tools are different from form builders, however, in that the result is just a picture - the widgets aren’t real, and they aren’t functional.</p>

<p>These wireframe tools strive for some degree of “sketchiness” in their look, so these are really medium-fidelity tools. Not as low fidelity as hand sketch, but still not what the final interface will look like.</p></div><div class="row"><div class="slide col-sm-6"><div class="slideTitle"><p>Pros &amp; Cons of Storyboarding</p></div>
 <ul><li><p></p><p>Pros</p><p></p>

 <ul><li><p>You can draw anything</p></li></ul></li>
 <li><p></p><p>Cons</p><p></p>

 <ul><li><p>No text entry</p></li>
 <li><p>Widgets aren’t active</p></li>
 <li><p>“Hunt for the hotspot”</p></li></ul></li></ul></div>

<p>The big advantage of storyboarding is similar to the advantage of paper: you can draw anything on a storyboard. That frees your creativity in ways that a form builder can’t, with its fixed palette of widgets.</p>

<p>The disadvantages come from the storyboard’s static nature. Some tools let you link the pictures together with hyperlinks, but even then all you can do is click, not really interact. Watching a real user in front of a storyboard often devolves into a game of “<strong>hunt for the hotspot</strong>“, like children’s software where the only point is to find things on the screen to click on and see what they do. The hunt-for-the-hotspot effect means that storyboards are largely useless for user testing, unlike paper prototypes. In general, horizontal computer prototypes are better evaluated with other techniques, like heuristic evaluation (which we’ll discuss in a future reading).</p></div><div class="row"><div class="slide col-sm-6"><div class="slideTitle"><p>Form Builders</p></div>

<ul><li><p>Mac Interface Builder</p></li>
<li><p>Qt Designer</p></li>
<li><p>FlexBuilder</p></li>
<li><p>Silverlight</p></li>
<li><p></p><p>Visual Basic</p><p></p></li>
<li><p></p><p>Tips</p><p></p>

<ul><li><p>Use absolute positioning for now</p></li></ul></li></ul></div>

<p>Here are some form builder tools.</p></div><div class="row"><div class="slide col-sm-6"><div class="slideTitle"><p>Pros &amp; Cons of Form Builders</p></div>

<ul><li><p></p><p>Pros</p><p></p>

<ul><li><p>Actual controls, not just pictures of them</p></li>
<li><p>Can hook in some backend if you need it</p><ul><li><p>But then you won’t want to throw it away</p></li></ul><p></p></li></ul></li>
<li><p></p><p>Cons</p><p></p>

<ul><li><p>Limits thinking to standard widgets</p></li>
<li><p>Less helpful for rich graphical interfaces</p></li></ul></li></ul></div>

<p>Unlike storyboards, form builders use actual working widgets, not just static pictures. So the widgets look the same as they will in the final implementation (assuming you’re using a compatible form builder - a prototype in Visual Basic may not look like a final implementation in Java).</p>

<p>Also, since form builders usually have an implementation language underneath them - which may even be the same implementation language that you’ll eventually use for your final interface – you can also hook in as much or as little backend as you want.</p>

<p>On the down side, form builders give you a fixed palette of standard widgets, which limits your creativity as a designer, and which makes form builders far less useful for prototyping rich graphical interfaces, e.g., a circuit-drawing editor. Form builders are great for the menus and widgets that surround a graphical interface, but can’t simulate the “insides” of the application window.</p></div><div class="row"><div class="slide col-sm-6"><div class="slideTitle"><p>Wizard of Oz Prototype</p></div>

<ul><li><p>Software simulation with a human in the loop to help</p></li>
<li><p>“Wizard of Oz” = “man behind the curtain”</p>

<ul><li><p>Wizard is usually but not always hidden</p></li></ul></li>
<li><p>Often used to simulate future technology</p>

<ul><li><p>Speech recognition</p></li>
<li><p>Learning</p></li></ul></li>
<li><p>Issues</p>

<ul><li><p>Two UIs to worry about: user’s and wizard’s</p></li>
<li><p>Wizard has to be mechanical</p></li></ul></li></ul></div>

<p>Part of the power of paper prototypes is the depth you can achieve by having a human simulate the backend. A <strong>Wizard of Oz prototype</strong> also uses a human in the backend, but the frontend is an actual computer system instead of a paper mockup. The term Wizard of Oz comes from the movie of the same name, in which the wizard was a man hiding behind a curtain, controlling a massive and impressive display.</p>

<p>In a Wizard of Oz prototype, the “wizard” is usually but not always hidden from the user. Wizard of Oz prototypes are often used to simulate future technology that isn’t available yet, particularly artificial intelligence. A famous example was the listening typewriter (Gould, Conti, &amp; Hovanyecz, “<a href="http://dl.acm.org/citation.cfm?id=358100">Composing letters with a simulated listening typewriter</a>,” <em>CACM</em> v26 n4, April 1983). This study sought to compare the effectiveness and acceptability of isolated-word speech recognition, which was the state of the art in the early 80’s, with continuous speech recognition, which wasn’t possible yet. The interface was a speech-operated text editor. Users looked at a screen and dictated into a microphone, which was connected to a typist (the wizard) in another room. Using a keyboard, the wizard operated the editor showing on the user’s screen.</p>

<p>The wizard’s skill was critical in this experiment. She could type 80 wpm, she practiced with the simulation for several weeks (with some iterative design on the simulator to improve her interface), and she was careful to type exactly what the user said, even exclamations and parenthetical comments or asides. The computer helped make her responses a more accurate simulation of computer speech recognition. It looked up every word she typed in a fixed dictionary, and any words that were not present were replaced with X’s, to simulate misrecognition. Furthermore, in order to simulate the computer’s ignorance of context, homophones were replaced with the most common spelling, so “done” replaced “dun”, and “in” replaced “inn”. The result was an extremely effective illusion. Most users were surprised when told (midway through the experiment) that a human was listening to them and doing the typing.</p>

<p>Thinking and acting mechanically is harder for a wizard than it is for a paper prototype simulator, because the tasks for which Wizard of Oz testing is used tend to be more “intelligent”. It helps if the wizard is personally familiar with the capabilities of similar interfaces, so that a realistic simulation can be provided. (See Maulsby et al, <a href="http://luca.bisognin.online.fr/icp/biblio/University_of_Calgary/maulsby93prototyping.pdf">“Prototyping an intelligent agent through Wizard of Oz”</a>, CHI 1993.) It also helps if the wizard’s interface can intentionally dumb down the responses, as was done in the Gould study.</p>

<p>A key challenge in designing a Wizard of Oz prototype is that you actually have two interfaces to worry about: the user’s interface, which is presumably the one you’re testing, and the wizard’s.</p>

<div class="reading-exercises exercises panel-group converted" id="ex_2"><h4 class="text-danger">reading exercises</h4>

<div class="panel panel-danger"><div class="panel-heading" data-target="#ex_2-exercise" data-toggle="collapse"><span class="panel-title">Exercise (Self Study)</span></div><div class="panel-collapse collapse exercise-panel" id="ex_2-exercise" data-outline="exercise" data-ex-id="computer_prototypes/exercise" data-ex-category="reading-exercises" data-ex-remote="https://rcm.scripts.mit.edu/handx/sp18/submit.php" data-ex-handout="classes-11-prototyping"><div class="panel-body"><p>Which of the following statements are true? (choose all good answers)</p><div class="form-group exercise-part" data-outline="a"><div class="checkbox exercise-choice" data-outline="Both paper prototyping and Wizard of Oz have a human simulating the computer"><label for="md_converted_choice_2_0"><input type="checkbox" id="md_converted_choice_2_0">Both paper prototyping and Wizard of Oz have a human simulating the computer</label><span class="exercise-answer exercise-remote" style="display: none;">(missing answer)</span></div>
<div class="checkbox exercise-choice" data-outline="Google Street View would be easy to prototype in a typical form builder"><label for="md_converted_choice_2_1"><input type="checkbox" id="md_converted_choice_2_1">Google Street View would be easy to prototype in a typical form builder</label><span class="exercise-answer exercise-remote" style="display: none;">(missing answer)</span></div>
<div class="checkbox exercise-choice" data-outline="Throw-away prototypes generally result in better final implementations"><label for="md_converted_choice_2_2"><input type="checkbox" id="md_converted_choice_2_2">Throw-away prototypes generally result in better final implementations</label><span class="exercise-answer exercise-remote" style="display: none;">(missing answer)</span></div>
</div><div class="exercise-explain exercise-remote"><p>(missing explanation)</p></div><div class="form-inline"><div class="form-group"><button class="btn hidden btn-default exercise-submit">check</button> <button class="btn btn-default exercise-reveal" style="display: none;">explain</button></div><div class="exercise-progress progress"><div class="progress-bar progress-bar-danger progress-bar-striped active"></div></div><div class="exercise-error"></div></div></div></div></div>



</div></div><div class="row"><div class="slide col-sm-6"><div class="slideTitle"><p>Summary</p></div>

<ul><li><p>Prototype fidelity</p>

<ul><li><p>Depth, breadth, look, feel</p></li></ul></li>
<li><p>Kinds of prototypes</p>

<ul><li><p>Paper</p></li>
<li><p>Computer: storyboard, forms</p></li>
<li><p>Wizard of Oz</p></li></ul></li>
<li><p>Don’t get attached to a prototype</p>

<ul><li><p>Because it may need to be thrown away</p></li></ul></li></ul></div></div></div>

















</div></div>

</main>
<footer class="col-sm-2 footer-margin"><div>Collaboratively authored with contributions from: Elena Glassman, Philip Guo, Daniel Jackson, David Karger, Juho Kim, Rob Miller, Stefanie Mueller, Clayton Sims, and Haoqi Zhang. This work is licensed under <a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/">CC&nbsp;BY-SA&nbsp;4.0</a>.</div></footer>
<script charset="utf-8" src="../../web/jquery.min.js"></script>


<script charset="utf-8" src="../../web/bootstrap.min.js"><footer>SPU ECS</footer><script charset="utf-8" src="../../web/handout-run.js"></script></body>
<!-- Mirrored from web.mit.edu/6.813/www/sp18/classes/11-prototyping/ by HTTrack Website Copier/3.x [XR&CO'2014], Thu, 19 Dec 2019 22:04:04 GMT -->
</html><!-- Handout delivered Thu Feb 22 2018 16:11:11 GMT-0500 (EST) -->