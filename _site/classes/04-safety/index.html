<!DOCTYPE html><html>
<!-- Mirrored from web.mit.edu/6.813/www/sp18/classes/04-safety/ by HTTrack Website Copier/3.x [XR&CO'2014], Thu, 19 Dec 2019 21:50:05 GMT -->
<head>
<meta charset="UTF-8">

<title>Reading 4: Safety</title>


<style type="text/css">
.small-img{
	width: 50% !important;}
</style>

<link href="../../web/handout-style.css" rel="stylesheet"><meta name="viewport" content="width=device-width, initial-scale=1"></head>
<body><header>CSC3220 Application Programming</a><div></div></header>
<nav class="table-of-contents col-sm-2"><ul class="nav"><li><a href="#reading_4_safety">Reading 4: Safety</a></li><li><a href="#human_error">Human Error</a></li><li><a href="#error_prevention">Error Prevention</a></li><li><a href="#error_messages">Error Messages</a></li><li><a href="#user_control_and_freedom">User Control and Freedom</a></li><li><a href="#undo">Undo</a></li></ul></nav>
<main class="container-fluid"><!--<iframe class="exercises-status" src="https://rcm.scripts.mit.edu/handx/sp18/status.php"></iframe>--><h1 class="handout-title col-sm-8 col-sm-offset-2" id="reading_4_safety">Reading 4: Safety</h1>

<div data-outline="reading_4_safety"><div class="markdown col-sm-8 col-sm-offset-2 converted"><div class="handout-info hidden alert alert-info"><p><strong>Reading exercises are due by 10pm the night before class.</strong></p></div>

<div class="row"><div class="slide col-sm-6"><div class="slideTitle"><p>UI Hall of Fame or Shame?</p></div>


<img src="figures/When2meet.jpg">

<h5><p>Doodle (for comparison)</p></h5>
<img src="figures/Doodle_example.jpg" class="small-img"></div>

<p>This is a snapshot of When2meet, one of the various web apps currently available for scheduling meeting times. The meeting coordinator is scheduling a weekly meeting, and has asked group members to enter their availability.</p>

<p>The interface for entering availability is distinct from (not externally consistent with) the typical interface for this task, which often has checkboxes or radio buttons for non-overlapping time slots of a fixed length. As a usability test, try entering your weekly availablity into our <a href="http://www.when2meet.com/?6030549-LHQ7M"></a></p><p><a href="http://www.when2meet.com/?6030549-LHQ7M">faux class meeting</a></p><p></p>

<p>How did you learn how to use it?</p>

<ul>
<li>Did you read the directions under the legend?</li>
<li>Did your cursor change as you moused over clickable areas? (A perceived affordance)</li>
<li>Did you just click around until something happened and learn a conceptual model based on the site’s immediate feedback?</li>
<li>How did you figure out how to undo a mistake?</li>
</ul>

<p>The interface is simple, and can be quickly learned. It starts as a wholly unavailable block, and the user can click and drag to sweep out periods of availability. And yet, it’s not safe.</p>

<p><strong>Half the members of the group entered the inverse of their availability</strong> into the site, triggering the scheduling process to start over.</p>

<ul>
<li>Is there something about the interface itself that encourages slips and mistakes?</li>
<li>Do you feel equally comfortable thinking about your schedule as periods of availability or unavailability? What change to the interface might help it match your internal representation of your schedule better?</li>
</ul></div>

<h2 id="human_error">Human Error</h2>

<div data-outline="human_error"><div class="row"><div class="slide col-sm-6"><div class="slideTitle"><p>Error Types</p></div>

<ul><li><p>Slips and lapses</p></li>
<ul><li><p>Failure to correctly execute a procedure</p></li>
<li><p>Slip is a failure of execution, lapse is a failure of memory</p></li>
<li><p>Typically found in skilled behavior</p></li></ul>
<li><p>Mistakes</p></li>
<ul><li><p>Using wrong procedure for the goal</p></li>
<li><p>Typically found in rule-based behavior or problem-solving behavior</p></li></ul></ul></div>

<p>Errors can be classified into <strong>slips and lapses</strong> and <strong>mistakes</strong> according to how they occur.</p>

<p>Slips and lapses are found in skilled behavior - execution of procedures that the user has already learned. For example, pressing an onscreen button - moving the mouse pointer over it, pressing the mouse button, releasing the mouse button - is a skill-based procedure for virtually any computer user. An error in executing this procedure, like clicking before the mouse pointer is over the button, is a slip. This is just a low-level example, of course. We have many higher-level, learned procedures too - attaching a file to an email, submitting a search to Google, drawing a rectangle in a paint program, etc. An error in execution of any learned procedure would be a slip.</p>

<p>Slips are distinguished from lapses by the source of the failure. A slip is a failure of execution or control - for example, substituting one action for another one in the procedure. A lapse is a failure of memory - for example, forgetting the overall goal, or forgetting where you are in the procedure.
A mistake, on the other hand, is an error made in planning or rule application. One framework for classifying cognitive behavior divides behavior into skill-based (learned procedures), rule-based (application of learned if-then rules), and knowledge-based (problem solving, logic, experimentation, etc.) Mistakes are errors in rulebased or knowlege-based behavior; e.g., applying a rule in a situation where it shouldn’t apply, or using faulty reasoning.</p>

<p>Overall, slips and lapses are more common than mistakes, because we spend most of our actual time executing learned procedures. If we spent most of our time problem-solving, we’d never get much done, because problem solving is such a slow, cognitively intensive, serial process. I’ve seen statistics that suggest that 60% of all errors are slips or lapses, but that’s highly dependent on context. Relative to their task, however, slips and lapses are less common than mistakes. That is, the chance that you’ll err executing any given step of a learned procedure is small–typically 1-5%, although that’s context dependent as well. The chance that you’ll err in any given step of rule-based or problem-solving behavior is much higher.</p>

<p>We won’t have much to say about mistakes in this reading, but much research in human error is concerned with this level - e.g., suboptimal or even irrational heuristics that people use for decision making and planning. A great reference about this is James Reason, Human Error, Cambridge University Press, 1990.</p></div><div class="row"><div class="slide col-sm-6"><div class="slideTitle"><p>Error Types</p></div>
<img src="figures/02.png"></div>

<p>Here’s a Venn diagram that shows the classification into mistakes and slips/lapses, with a finer categorization of slips discussed below.</p></div><div class="row"><div class="slide col-sm-6"><div class="slideTitle"><p>Capture Errors</p></div>
<ul><li><p>Leave your house and find yourself walking to school instead of where you meant to go</p></li>
<li><p>vi :w command (to save the file) vs. :wq command (to save and quit)</p></li>
<li><p>Excel array formulas must be entered with Ctrl-Shift-Enter, not just Enter</p></li></ul>
<img src="figures/03.png"></div>

<p>Here are some examples of common slips. A <strong>capture slip</strong> occurs when a person starts executing one sequence of actions, but then veers off into another (usually more familiar) sequence that happened to start the same way. A good mental picture for this is that you’ve developed a mental groove from executing the same sequence of actions repeatedly, and this groove tends to capture other sequences that start the same way. In the text editor vi, it’s common to quit the program by issuing the command “:wq”, which saves the file (w) and quits (q). If a user intends just to save the file (:w) but accidentally quits as well (:wq), then they’ve committed a capture error. Microsoft Excel has a curious (and very useful!) class of formulas called array formulas, but in order to get Excel to treat your formula as an array formula, you have to press Ctrl-Shift-Enter after you type it - every time you edit it. Why is this prone to capture slips? Because virtually every other edit you do is terminated by Enter, so you’re very likely to fall into that pattern automatically when you edit an array formula.</p></div><div class="row"><div class="slide col-sm-6"><div class="slideTitle"><p>Description Errors</p></div>
<img src="figures/04.png">
<ul><li><p>Consistency (same) is good for learning</p></li>
<li><p>Inadvertent similarity (close but not quite) is bad for safety</p></li></ul></div>

<p>A <strong>description slip</strong> occurs when two actions are very similar. The user intends to do one action, but accidentally substitutes the other. A classic example of a description error is reaching into the refrigerator for a carton of milk, but instead picking up a carton of orange juice and pouring it into your cereal. The actions for pouring milk in cereal and pouring juice in a glass are nearly identical - open fridge, pick up half-gallon carton, open it, pour- but the user’s mental description of the action to execute has substituted the orange juice for the milk.</p>

<p>Some other pairs that may be prone to description slips are shown above. In the GMail interface on the far right, the three icons - checkbox, star, and important - look very similar to each other when unchecked, opening the way to description slips.</p></div><div class="row"><div class="slide col-sm-6"><div class="slideTitle"><p>Mode Errors</p></div>
<ul><li><p>Modes: states in which actions have different meanings</p>

<ul><li><p>Vi’s insert mode vs. command mode</p></li>
<li><p>Caps Lock</p></li>
<li><p>Drawing Palette</p></li></ul></li></ul>
<img src="figures/05.png"></div>

<p>Another kind of error, clearly due to user interface, is a mode error. <strong>Modes</strong> are states in which the same action has different meanings. For example, when Caps Lock mode is enabled on a keyboard, the letter keys produce uppercase letters. The text editor vi is famous for its modes: in insert mode, letter keys are inserted into your text file, while in command mode (the default), the letter keys invoke editing commands. In the first reading, we talked about a mode error in Gimp: accidentally changing a menu shortcut because your mouse is hovering over it.</p>

<p>Mode errors occur when the user tries to invoke an action that doesn’t have the desired effect in the current mode. For example, if the user means to type lowercase letters but doesn’t notice that Caps Lock is enabled, then a mode error occurs.</p>

<p>Mode errors are generally slips, an error in the execution of a learned procedure, caused by failing to correctly evaluate the state of the interface.</p></div><div class="row"><div class="slide col-sm-6"><div class="slideTitle"><p>Causes of Slips</p></div>
<ul><li><p>“Strong-but-wrong” effect</p>

<ul><li><p>Similarity</p></li>
<li><p>High frequency</p></li></ul></li>
<li><p>Inattention or inappropriate attention</p></li>
<li><p>Speed / accuracy tradeoff</p></li></ul>
<img src="figures/06.png"></div>

<p>The slips and lapses we’ve discussed have a few features in common. First, the root cause of these errors is often <strong>inattention</strong>. Since slips and lapses occur in skilled behavior, execution of already well-learned procedures, they are generally associated with insufficient attention to the execution of the procedure, or omission or distraction of attention at a key moment.</p>

<p>Second, the particular erroneous behavior chosen is often selected because of its high similarity to the correct behavior (as in capture and description slips), or of its high frequency relative to the correct behavior (as in capture slips). Very common, or very similar, patterns are strongly available for retrieval from human memory. Errors are often <strong>strong-but-wrong</strong> behavior.</p>

<p>Finally, we can tune our performance to various points on a <strong>speed-accuracy</strong> tradeoff curve. We can force ourselves to make decisions faster (shorter reaction time) at the cost of making some of those decisions wrong.</p>

<p>Conversely, we can slow down, take a longer time for each decision and improve accuracy. It turns out that for skill-based decision making, reaction time varies linearly with the log of odds of correctness; i.e., a constant increase in reaction time can double the odds of a correct decision.</p>

<p>The speed-accuracy curve isn’t fixed; it can be moved down and to the right by practicing the task. Also, people have different curves for different tasks; a pro tennis player will have a high curve for tennis but a low one for surgery.</p>

<p>One consequence of this idea is that <strong>efficiency</strong> can be traded off against <strong>safety</strong>. Most users will seek a speed that keeps slips to a low level, but doesn’t completely eliminate them.</p>

<div class="reading-exercises exercises panel-group converted" id="ex"><h4 class="text-danger">reading exercises</h4>

<div class="panel panel-danger"><div class="panel-heading" data-target="#ex-exercise" data-toggle-no="collapse"><span class="panel-title">Exercise (Self Study)</span></div><div class="panel-collapse kkkcollapse exercise-panel" id="ex-exercise" data-outline="exercise" data-ex-id="human_error/exercise" data-ex-category="reading-exercises" data-ex-remote="https://rcm.scripts.mit.edu/handx/sp18/submit.php" data-ex-handout="classes-04-safety"><div class="panel-body"><p>Which of the following affect the likelihood of slips? (choose all good answers)</p><div class="form-group exercise-part" data-outline="a"><div class="checkbox exercise-choice" data-outline="frequency of use"><label for="md_converted_choice_1_0"><input type="checkbox" id="md_converted_choice_1_0">frequency of use</label><span class="exercise-answer exercise-remote" style="display: none;">(missing answer)</span></div>
<div class="checkbox exercise-choice" data-outline="working quickly"><label for="md_converted_choice_1_1"><input type="checkbox" id="md_converted_choice_1_1">working quickly</label><span class="exercise-answer exercise-remote" style="display: none;">(missing answer)</span></div>
<div class="checkbox exercise-choice" data-outline="similarity of choices"><label for="md_converted_choice_1_2"><input type="checkbox" id="md_converted_choice_1_2">similarity of choices</label><span class="exercise-answer exercise-remote" style="display: none;">(missing answer)</span></div>
<div class="checkbox exercise-choice" data-outline="attention elsewhere"><label for="md_converted_choice_1_3"><input type="checkbox" id="md_converted_choice_1_3">attention elsewhere</label><span class="exercise-answer exercise-remote" style="display: none;">(missing answer)</span></div>
</div><div class="form-inline"><div class="form-group"><button class="btn hidden btn-default exercise-submit">check</button> <button class="btn btn-default exercise-reveal" style="display: none;">explain</button></div><div class="exercise-progress progress"><div class="progress-bar progress-bar-danger progress-bar-striped active"></div></div><div class="exercise-error"></div></div></div></div></div>

</div></div></div>











<h2 id="error_prevention">Error Prevention</h2>

<div data-outline="error_prevention"><div class="row"><div class="slide col-sm-6"><div class="slideTitle"><p>Safety from Capture Errors</p></div>
<ul><li><p>Avoid habitual action sequences with identical prefixes</p></li></ul></div>

<p>Let’s discuss how to prevent errors of these sorts. In a computer interface, you can deal with capture errors by avoiding very common action sequences that have identical prefixes.</p></div><div class="row"><div class="slide col-sm-6"><div class="slideTitle"><p>Causes of Slips</p></div>
<ul><li><p>Avoid actions with very similar descriptions</p></li>
<li><p>Keep dangerous commands away from common ones</p></li></ul>
<img src="figures/07.png"></div>

<p>Description errors can be fought off by applying the converse of the Consistency heuristic: different things should look and act different, so that it will be harder to make description errors between them. Avoid actions with very similar descriptions, like long rows of identical buttons.</p>

<p>You can also reduce description errors by making sure that dangerous functions (hard to recover from if invoked accidentally) are well-separated from frequently-used commands. Outlook 2003 makes this mistake: when you right-click on an email attachment, you get a menu that mixes common commands (Open, Save As) with less common and less recoverable ones - if you print that big file by mistake, you can’t get the paper back. And if you Remove the attachment, it’s even worse - undo won’t bring it back! (Thanks to Amir Karger for this example.)</p>

<p>Unfortunately the Mail app on the iPad <strong>also</strong> makes this mistake - the Delete and Reply buttons are right next to each other. (thanks to Alexander Ivanov for this example)</p></div><div class="row"><div class="slide col-sm-6"><div class="slideTitle"><p>Safety from Mode Errors</p></div>
<ul><li><p>Eliminate modes</p></li>
<li><p>Increase visibility of mode</p></li>
<li><p>Spring-loaded or temporary modes</p></li>
<li><p>Disjoint action sets in different modes</p></li></ul></div>

<p>There are many ways to avoid or mitigate mode errors. Eliminating the modes entirely is best, although not always possible. Modes do have some uses - they make command sets smaller, for example. When modes are necessary, it’s essential to make the mode visible. But visibility is a much harder problem for mode status than it is for affordances. When mode errors occur, the user isn’t actively looking for the mode, like they might actively look for a control. As a result, mode status indicators must be visible in the user’s locus of attention.
That’s why the Caps Lock light, which displays the status of the Caps Lock mode on a keyboard, doesn’t really work.</p>

<p>Other solutions are spring-loaded or temporary modes. With a spring-loaded mode, the user has to do something active to stay in the alternate mode, essentially eliminating the chance that they’ll forget what mode they’re in. The Shift key is a spring-loaded version of the uppercase mode. Drag-and-drop is another springloaded mode; you’re only dragging as long as you hold down the mouse button. Temporary modes are similarly short-term. For example, in many graphics programs, when you select a drawing object like a rectangle or line from the palette, that drawing mode is active only for one mouse gesture. Once you’ve drawn one rectangle, the mode automatically reverts to ordinary pointer selection.</p>

<p>Finally, you can also mitigate the effects of mode errors by designing action sets so that no two modes share any actions. Mode errors may still occur, when the user invokes an action in the wrong mode, but the action can simply be ignored rather than triggering any undesired effect.</p></div><div class="row"><div class="slide col-sm-6"><div class="slideTitle"><p>Confirmation Dialogs</p></div>
<img src="figures/confirmation-4.png">
<img src="figures/confirmation-1.png" style="width:70%">
<img src="figures/confirmation-3.png">
<img src="figures/confirmation-2.png" style="width:50%"></div>

<p>An unfortunately common strategy for error prevention is the <strong>confirmation dialog</strong>, or “Are you sure?” dialog.</p>

<p>It’s not a good approach, and should be used only sparingly, for several reasons:</p>

<ul>
<li>Confirmation dialogs can substantially reduce the efficiency of the interface. In the example above, a confirmation dialog pops up whenever the user deletes something, forcing the user to make two button presses for every delete, instead of just one. Frequent commands should avoid confirmations.</li>
<li>If a confirmation dialog is frequently seen - for example, every time the Delete button is pressed - then the expert users will learn to expect it, and will start to include it in their habitual procedure. In other words, to delete something, the user will learn to push Delete and then OK, without reading or even thinking about the confirmation dialog! The dialog has then completely lost its effectiveness, serving only to slow down the interface without actually preventing any errors.</li>
</ul>

<p>In general, reversibility (i.e. <strong>undo</strong>) is a far better solution than confirmation.</p>

<p>Even a web interface can provide at least single-level undo (undoing the last operation). Operations that are very hard to reverse may deserve confirmation, however. For example, quitting an application with unsaved work is hard to undo - but a welldesigned application could make even this undoable, using automatic save or keeping unsaved drafts in a special directory.</p>

<div class="reading-exercises exercises panel-group converted" id="ex_2"><h4 class="text-danger">reading exercises</h4>

<div class="panel panel-danger"><div class="panel-heading" data-target="#ex_2-exercise" data-toggle-no="collapse"><span class="panel-title">Exercise (Self Study)</span></div><div class="panel-collapse kkkcollapse exercise-panel" id="ex_2-exercise" data-outline="exercise" data-ex-id="error_prevention/exercise" data-ex-category="reading-exercises" data-ex-remote="https://rcm.scripts.mit.edu/handx/sp18/submit.php" data-ex-handout="classes-04-safety"><div class="panel-body"><p>Which of the following are effective ways to reduce mode errors? (choose all good answers)</p><div class="form-group exercise-part" data-outline="a"><div class="checkbox exercise-choice" data-outline="combining different modes into one mode"><label for="md_converted_choice_2_0"><input type="checkbox" id="md_converted_choice_2_0">combining different modes into one mode</label><span class="exercise-answer exercise-remote" style="display: none;">(missing answer)</span></div>
<div class="checkbox exercise-choice" data-outline="making a mode last only while the user is holding down a button"><label for="md_converted_choice_2_1"><input type="checkbox" id="md_converted_choice_2_1">making a mode last only while the user is holding down a button</label><span class="exercise-answer exercise-remote" style="display: none;">(missing answer)</span></div>
<div class="checkbox exercise-choice" data-outline="displaying a mode indicator in the window’s statusbar"><label for="md_converted_choice_2_2"><input type="checkbox" id="md_converted_choice_2_2">displaying a mode indicator in the window’s statusbar</label><span class="exercise-answer exercise-remote" style="display: none;">(missing answer)</span></div>
</div><div class="exercise-explain exercise-remote"><p>(missing explanation)</p></div><div class="form-inline"><div class="form-group"><button class="btn hidden btn-default exercise-submit">check</button> <button class="btn btn-default exercise-reveal" style="display: none;">explain</button></div><div class="exercise-progress progress"><div class="progress-bar progress-bar-danger progress-bar-striped active"></div></div><div class="exercise-error"></div></div></div></div></div>



</div></div></div>







<h2 id="error_messages">Error Messages</h2>

<div data-outline="error_messages"><div class="row"><div class="slide col-sm-6"><div class="slideTitle"><p>Writing Error Message Dialogs</p></div>
<ul><li><p>Best error message is <em>none at all</em></p></li>
<ul><li><p>Errors should be prevented</p></li>
<li><p>Be more flexible and tolerant</p></li>
<li><p>Nonsense entries can often be ignored without harm</p></li></ul></ul>
<img src="figures/17.png"></div>

<p>Finally, let’s talk about how to write error messages. But before you try to write an error message, stop and ask yourself whether it’s really necessary. An error message is evidence of a limitation or lack of flexibility on the part of the system - a failure to prevent an error or absorb it without complaint. So try to <strong>eliminate the error</strong> first.</p>

<p>Some errors simply aren’t worth a message. For example, suppose the user types “abc” into the font size combo box. Don’t pop up a message complaining about an “invalid entry”. Just ignore it and immediately replace it with the current font size. (Why is this enough feedback, for a font size combo box?) Similarly, if the user drags a scrollbar thumb too far, the scrollbar doesn’t pop up an error message (“Too far! Too far!”). It simply stops. If the effect of the erroneous action is easily visible, as in these cases, then you don’t have to beat the user over the head with a superfluous error message.</p>

<p>The figure shows an example of an error message that simply shouldn’t happen. Forbidding dashes and spaces in a number that the user must type, like an account number or credit card number, is poisonous to usability. (Why are dashes and spaces helpful for human perception and memory?) There’s a great collection of error messages like this at the No Dashes or Spaces Hall of Shame (<a href="http://www.unixwiz.net/ndos-shame.html">http://www.unixwiz.net/ndos-shame.html</a>).</p></div><div class="row"><div class="slide col-sm-6"><div class="slideTitle"><p>Be Precise and Comprehensible</p></div>
<ul><li><p>Be precise</p></li>
<li><p>Restate user’s input</p></li>
<li><p>Speak the user’s language</p></li></ul></div>

<p>Assuming you can’t design the error message out of the system, here are some guidelines for writing good ones.</p>

<p>Be precise. Don’t lump together multiple error conditions into a single all-purpose message. Find out what’s really wrong, and display a targeted message.</p>

<p>If the error is due to limitations of your system, like sizes or allowed characters, then be specific about what the limitations are, so that the user can adapt. (Then ask yourself why you have those limitations!)</p>

<p>It often helps to restate the user’s input, so that they can relate what they did to the error message, and perhaps even detect the problem immediately (“oh, I didn’t mean paper.doc…”)</p>

<p>In error messages, it’s particularly important to speak the user’s language, and avoid letting technical terms or details like exceptions and stack traces leak through.</p></div><div class="row"><div class="slide col-sm-6"><div class="slideTitle"><p>Suggest Reasons and Solutions</p></div>
<ul><li><p>Give <strong>constructive</strong> help: why the error occured and how to fix it</p></li></ul>
<img src="figures/18.png"></div>

<p>Next, your message should be <strong>constructive</strong>, not just reporting the error but helping the user correct it. Suggest possible reasons for the error and offer ways to correct them–ideally in the error message dialog itself. Here’s a good example from Adobe Acrobat.</p></div><div class="row"><div class="slide col-sm-6"><div class="slideTitle"><p>Be Polite</p></div>
<ul><li><p>Be polite and nonblaming</p></li></ul>
<img src="figures/19.png"></div>

<p>Finally, be polite. The message should be worded to take as much blame as possible away from the user and heap the blame instead on the system. Save the user’s face; don’t worry about the computer’s. The computer doesn’t feel it, and in many cases it is the interface’s fault anyway for not finding a way to prevent the error in the first place. It’s interesting to contrast what the original 1984 Mac said when it crashed (an apology!) with the dialog shown below.</p>

<p>The confirmation dialog on the bottom isn’t an error message, strictly speaking, but it does show incorrect attribution of blame. The user shouldn’t have to apologize!</p></div><div class="row"><div class="slide col-sm-6"><div class="slideTitle"><p>Avoid Loaded Words</p></div>
<ul><li><p>Fatal, illegal, aborted, terminated</p></li></ul>
<img src="figures/20.png"></div>

<p>Many words that are unfortunately common in technical error messages have emotionally-charged meanings in ordinary language; examples include “fatal”, “illegal”, “abort”, etc. Avoid them. Use neutral language.
Windows and DOS have historically been littered with messages like these.</p>

<p>The tooltip shown at the bottom isn’t strictly an error message, but it actually appeared in a production version of AutoCad! As the story goes, it was inserted by a programmer as a joke, but somehow never removed before release. Even as a joke, it demonstrates a lack of respect for the intelligence of the human being on the other side of the screen. That attitude is exactly wrong for user interface design.</p></div><div class="reading-exercises exercises panel-group converted" id="ex_3"><h4 class="text-danger">reading exercises</h4>

<div class="panel panel-danger"><div class="panel-heading" data-target="#ex_3-exercise" data-toggle-no="collapse"><span class="panel-title">Exercise (Self Study)</span></div><div class="panel-collapse kkkcollapse exercise-panel" id="ex_3-exercise" data-outline="exercise" data-ex-id="error_messages/exercise" data-ex-category="reading-exercises" data-ex-remote="https://rcm.scripts.mit.edu/handx/sp18/submit.php" data-ex-handout="classes-04-safety"><div class="panel-body"><p>Suppose you’re a UI designer reviewing an error message in order to improve it.  Which of the following are good questions to ask? (choose all good answers)</p><div class="form-group exercise-part" data-outline="a"><div class="checkbox exercise-choice" data-outline="does it speak the user’s language?"><label for="md_converted_choice_3_0"><input type="checkbox" id="md_converted_choice_3_0">does it speak the user’s language?</label><span class="exercise-answer exercise-remote" style="display: none;">(missing answer)</span></div>
<div class="checkbox exercise-choice" data-outline="does it restate the user’s input?"><label for="md_converted_choice_3_1"><input type="checkbox" id="md_converted_choice_3_1">does it restate the user’s input?</label><span class="exercise-answer exercise-remote" style="display: none;">(missing answer)</span></div>
<div class="checkbox exercise-choice" data-outline="can this error be prevented entirely?"><label for="md_converted_choice_3_2"><input type="checkbox" id="md_converted_choice_3_2">can this error be prevented entirely?</label><span class="exercise-answer exercise-remote" style="display: none;">(missing answer)</span></div>
<div class="checkbox exercise-choice" data-outline="is it necessary do display this error message at all?"><label for="md_converted_choice_3_3"><input type="checkbox" id="md_converted_choice_3_3">is it necessary do display this error message at all?</label><span class="exercise-answer exercise-remote" style="display: none;">(missing answer)</span></div>
</div><div class="form-inline"><div class="form-group"><button class="btn hidden btn-default exercise-submit">check</button> <button class="btn btn-default exercise-reveal" style="display: none;">explain</button></div><div class="exercise-progress progress"><div class="progress-bar progress-bar-danger progress-bar-striped active"></div></div><div class="exercise-error"></div></div></div></div></div>

</div></div>











<h2 id="user_control_and_freedom">User Control and Freedom</h2>

<div data-outline="user_control_and_freedom"><div class="row"><div class="slide col-sm-6"><div class="slideTitle"><p>User Control and Freedom</p></div>
<ul><li><p>Learning by doing</p></li>
<li><p>Dealing with errors</p></li>
<li><p>User is sentinent, computer is not</p></li></ul></div>

<p>Good interfaces are <strong>explorable</strong>. Recall that a major way users learn is by doing: poking around an interface, trying things out. An interface should encourage this kind of exploration, not only by making things more visible, but also by making the consequences of errors less severe.</p>

<p>For example, users navigating around a 3D world or a complex web site can easily get lost; give them an easy, obvious way to get back to some “home”, or default view. Users should be able to explore the interface without fear of being trapped in a corner.</p>

<p><strong>User control and freedom</strong> (a term coined by Jakob Nielsen) is the idea that in the give and take between the user and the system, the user should have ultimate control.</p></div><div class="row"><div class="slide col-sm-6"><div class="slideTitle"><p>Clearly Marked Exits</p></div>
<ul><li><p>Long operations should be cancelable</p></li>
<img src="figures/21.png">
<li><p>All dialogs should have a cancel button</p></li>
<img src="figures/22.png"></ul></div>

<p>The simplest kind of user control is a veto - the ability to <strong>cancel</strong> an operation, even if it was something they asked for. Users should not be trapped by the interface. Long operations should not only have a progress bar, but a Cancel button too. Likewise, every dialog box should have a Cancel button. Where is it in this CuteFTP dialog box on the bottom? As a user of this dialog, would you feel like you’re in control?</p></div><div class="row"><div class="slide col-sm-6"><div class="slideTitle"><p>Wizard vs. Center Stage: Who’s in Control?</p></div>

<p><strong>Wizard</strong></p>

<img src="figures/23a.png">

<p><strong>Center Stage</strong></p>

<img src="figures/23b.png"></div>

<p>Let’s look a little further at who controls the dialog between the user and the system. (Here, dialog means the general pattern of back-and-forth communication between the user and the interface, as if the user and the system are having a conversation. A dialog box is a specific kind of window, a design pattern used in a dialog.</p>

<p>We often say dialog as a shorthand for dialog box, but hopefully the distinction will be obvious from context.)</p>

<p>We’ll contrast two patterns. The <em>wizard</em> design pattern is a familiar pattern for improving the learnability of a complex interaction, by structuring it as a step-by-step process, showing each step in a dialog box. Wizards are the conventional pattern for software installation. In a wizard, the system controls the dialog - it dictates the steps, the ordering of the steps, and what it asks for at each step. Imagine a sales agent who’s asking you a series of questions, and refuses to listen to what you say if it’s not relevant to the question they asked. That’s a wizard.</p>

<p>Contrast that with the <em>center stage</em> pattern, which lays out data objects in the main section of the window, and gives the user a set of tools for operating on the objects. In this case, the user controls the dialog, deciding which objects to select and which tools to pick up.</p>

<p>Wizards clearly restrict the user’s freedom, but for complex, infrequently-done tasks (like installation), the tradeoff is often worth it. Note, however, that a good wizard has two key features: a Back button (for backing out of errors) and a Cancel button (for vetoing the operation entirely). So even though the wizard pattern puts the system in control of the details, the user still has supervisory control.</p></div><div class="row"><div class="slide col-sm-6"><div class="slideTitle"><p>Manual Overrides for Automatic Systems</p></div>
<img src="figures/24a.png">
<img src="figures/24b.png">
<img src="figures/24c.png"></div>

<p>One of the main reasons we build software in the first place is to automate a process, taking some burden off the human users. But we can’t take away control entirely. Users should be able to manually override automation.</p>

<p>The familiar Find &amp; Replace command is a simple example of this. If Find &amp; Replace were perfectly automatable, then all we’d need is Replace All. But the world isn’t that simple, and our documents are full of exceptions or incompletely-specified patterns, and there are plenty of cases where the user needs manual control over replacement - hence the Find Next and Replace buttons.
Google Maps offers an example of a different kind of control - starting with the output of an automatic algorithm (the shortest route between two points) and manually tweaking it (dragging the route around).</p>

<p>Systems that solve big or complex optimization problems should offer the user the opportunity to make these tweaks, since often there are constraints or preferences that are difficult to specify in advance, but can easily be seen when a solution is presented.</p>

<p>Some HCI researchers (prominently, Austin Henderson) argue that computer science in general, and corporate system developers in particular, have gone too far in trying to regularize the world, building systems that demand coherence from their users and their environment, expecting input that fits into expected categories and rejecting all others. For example, stating that every person has a first name and a last name, or assuming that every city belongs to only one country, or demanding a single shipping address for an order, are claims about the coherence of the world. But the real world is fuzzy, full of exceptions and oddities, and we should build pliant systems that can survive the exceptions. A great example of how paper-based systems are pliant is the marginal comment. Here’s a card from an old-fashioned card catalog. You can easily distinguish the coherent typewritten data, which might fit neatly into a database system nowadays, from the marginalia.</p>

<p>Margins on paper forms are often used by experienced workers to get their jobs done when the form is inadequate. We have a few design patterns for pliant user interfaces - such as comment fields (though they appear very rarely in business software!), and tagging instead of rigid hierarchies - but we don’t really know how to build systems that are coherent enough for automation yet still pliant enough for the real world. (Jon Udell, “<a href="http://www.infoworld.com/article/2666464/application-development/filling-in-the-margins.html">Filling in the Margins</a>“)</p></div><div class="row"><div class="slide col-sm-6"><div class="slideTitle"><p>Never Ask Me Again</p></div>
<img src="figures/25a.png">
<img src="figures/25b.png"></div>

<p>Here’s an interesting problem related to who’s in control of the dialog. Many interfaces interrupt users with questions, like the dialog boxes shown here. If the answer is always the same, it’s clearly inefficient (and annoying) to keep asking the same question repeatedly - so many of these dialogs offer the option Never ask me again.</p>

<p>Good idea, and superficially seems to improve user control, because it’s like a veto over all future questions of the same type. But suppose later the user wants to change their decision? Because the system initiated this dialog, not the user, the user has no idea how to return to the question. And the system has promised never to ask it again! It’s a Catch-22.</p>

<p>One patch to this problem can be seen in the Firefox dialog box on the bottom - a help message that tells the user where to look to undo the decision. But remember that just because the user has seen a message doesn’t mean they’ve learned what it had to say. It’s not clear that this really fixes the problem, but I haven’t seen any better solutions.</p></div><div class="row"><div class="slide col-sm-6"><div class="slideTitle"><p>User Control Over Data</p></div>
<ul><li><p>Data entered by the user should be editable by the user</p></li>
<li><p>UI should give the power to:</p>

<ul><li><p>Create a data item</p></li>
<li><p>Read it</p></li>
<li><p>Update it</p></li>
<li><p>Delete it</p></li></ul></li></ul></div>

<p>So we’ve discussed user control over the dialog. Let’s now consider user control over the data itself.</p>

<p>Editing is important. If the user is asked to provide any kind of data - whether it’s the name of an object, a list of email attachments, or the position of a rectangle - the interface should provide a way to go back and change what the user originally entered - rename the object, add or remove attachments, move around that rectangle some more. Data that is initialized by the user but can never again be touched will frustrate user control and freedom.
Keep CRUD in mind - if you can Create an object or data field, you should be able to Read, Update, and Delete it, too.</p>

<p>Providing user control and freedom can have strong effects on your backend model. You’ll have to make sure data are mutable. If you built your backend assuming that a user-provided piece of data would never change once it had been created, then you may have trouble building a good UI. One way that can happen is if you try to use user-provided data as a unique identifier in a database, like the user’s name, or their email address, or their phone number, or the title of a document. That’s generally not a good practice, because if any other object stores a reference to the identifier, then the user won’t be able to edit the identifier without breaking that reference.</p></div><div class="row"><div class="slide col-sm-6"><div class="slideTitle"><p>No Arbitrary Limits on User-Defined Names</p></div>
<img src="figures/14.png"></div>

<p>If an interface allows users to name things, then users should be free to choose long, descriptive names, with any characters or punctuation they want. Artificial limits on length or content should be avoided. DOS used to have a strong limit on filenames, an 8 character name and a 3 character extension, and a variety of punctuation characters are forbidden from filenames. Echoes of these limits persist in Windows even today.</p>

<p>Here’s a bizarre requirement from Facebook (source: Error’d–The Daily WTF). No doubt the programmer’s intention was to reject randomly-generated or nonsensical names which would reduce Facebook’s appearance of professionalism, but the rule clearly doesn’t work.</p>

<div class="reading-exercises exercises panel-group converted" id="ex_4"><h4 class="text-danger">reading exercises</h4>

<div class="panel panel-danger"><div class="panel-heading" data-target="#ex_4-exercise" data-toggle-no="collapse"><span class="panel-title">Exercise (Self Study)</span></div><div class="panel-collapse kkkcollapse exercise-panel" id="ex_4-exercise" data-outline="exercise" data-ex-id="user_control_and_freedom/exercise" data-ex-category="reading-exercises" data-ex-remote="https://rcm.scripts.mit.edu/handx/sp18/submit.php" data-ex-handout="classes-04-safety"><div class="panel-body"><p>Which of the following are correct connections of user freedom failures with the letters of CRUD? (choose all good answers)</p><div class="form-group exercise-part" data-outline="a"><div class="checkbox exercise-choice" data-outline="username can’t be changed after creating an account is a C failure"><label for="md_converted_choice_4_0"><input type="checkbox" id="md_converted_choice_4_0">username can’t be changed after creating an account is a C failure</label><span class="exercise-answer exercise-remote" style="display: none;">(missing answer)</span></div>
<div class="checkbox exercise-choice" data-outline="instant messaging client that shows only the messages you receive, not the messages you send, is an R failure"><label for="md_converted_choice_4_1"><input type="checkbox" id="md_converted_choice_4_1">instant messaging client that shows only the messages you receive, not the messages you send, is an R failure</label><span class="exercise-answer exercise-remote" style="display: none;">(missing answer)</span></div>
<div class="checkbox exercise-choice" data-outline="fixed list of #hashtags in Piazza is a C failure"><label for="md_converted_choice_4_2"><input type="checkbox" id="md_converted_choice_4_2">fixed list of #hashtags in Piazza is a C failure</label><span class="exercise-answer exercise-remote" style="display: none;">(missing answer)</span></div>
</div><div class="exercise-explain exercise-remote"><p>(missing explanation)</p></div><div class="form-inline"><div class="form-group"><button class="btn hidden btn-default exercise-submit">check</button> <button class="btn btn-default exercise-reveal" style="display: none;">explain</button></div><div class="exercise-progress progress"><div class="progress-bar progress-bar-danger progress-bar-striped active"></div></div><div class="exercise-error"></div></div></div></div></div>



</div></div></div>













<h2 id="undo">Undo</h2>

<div data-outline="undo"><div class="row"><div class="slide col-sm-6"><div class="slideTitle"><p>Support Undo</p></div>

<p><strong>Desktop</strong></p>

<img src="figures/15a.png" style="text-align:center; width:80%">

<p><strong>Web</strong></p>

<img src="figures/15b.png" style="text-align:center; width:80%">

<p><strong>Revision history</strong></p>

<img src="figures/15c.png" style="text-align:center; width:80%"></div>

<p>If Cancel is the most common answer for user control over dialog, then Undo is the most common answer to user control over data. Undo has been around in desktop applications since the dark ages of the first Macintosh, if not before. The first Mac applications supported only single-level undo - that is, you could undo the last command, but no farther. This was largely due to memory constraints, and modern desktop applications allow unlimited undo (or so much that it makes no difference given the current interface for Undo - nobody is going to press Ctrl-Z 1000 times, after all).</p>

<p>Undo is also gradually appearing in web applications, like GMail. GMail’s interface (shown here) only supports single undo. But other web applications support much longer undo histories, particularly apps designed for collaboration, like wikis. In these apps, undo typically takes the form of a revision history, rather than an undo command.</p></div><div class="row"><div class="slide col-sm-6"><div class="slideTitle"><p>Forming a Mental Model of Undo</p></div>
<ul><li><p>Undo reverses the effect of an action</p></li>
<li><p>But that leaves many questions:</p></li>
<ul><li><p>What stream of actions will be undone?</p></li>
<li><p>How is the stream divided into undoable units?</p></li>
<li><p>Which actions are undoable, and which are skipped?</p></li>
<li><p>How much of the previous state is actually recovered by the undo?</p></li>
<li><p>How far back in the stream can you undo?</p></li></ul></ul></div>

<p>You may think it’s obvious what the Undo command does: it reverses the effect of the user’s last action. But it’s not as simple as that. Undo’s behavior can be mysterious. Undo is an example of a case where the system model is not well communicated by the user interface. The actions managed by Undo are not visible; there’s no persistent, visual representation showing the next action to be undone. (Not quite true: in well-designed interfaces, the Undo menu command’s label gives a hint, like “Undo Typing” or “Undo Bold”. But it’s not prominent, so it doesn’t particularly help a user form their mental model from ordinary use.) If you ask users to predict what effect Undo will have in some particular case, they may have no idea.</p>

<p>Let’s look at some of the questions we should ask when we’re designing an undo mechanism.</p></div><div class="row"><div class="slide col-sm-6"><div class="slideTitle"><p>What will be undone?</p></div>
<ul><li><p>Actions in this window (MS Word) or entire app (MS Excel)</p></li>
<li><p>Actions in this text widget (Web browser)</p></li>
<li><p>Just my actions, or everybody’s? (multiuser apps)</p></li>
<li><p>Actions made by the computer</p></li>
<ul><li><p>MS Office AutoCorrect and AutoFormat are undoable, even though the user didn’t do them</p></li></ul></ul></div>

<p>Undo reverses the last action made by the user, but it’s not necessarily the last one in the global stream. There is no global Undo in current GUI environments. Each application, sometimes even each widget, offers its own Undo command. A particular Undo command will only affect the action stream of the application or widget that it controls - so it will undo the last action in that application or widget’s stream, which isn’t necessarily the last command the user issued to the system as a whole.</p>

<p>Some applications use a separate action stream for each window. Microsoft Word works this way, for example. If you type something into Word document A, then type something else into Word document B, then switch back to A and invoke Undo, then A’s insert will be undone - even though B’s insert is the last one you actually performed.  But Microsoft Excel, despite being part of the same office suite, has a <em>global</em> action stream.  Invoking Undo undoes actions from across all open Excel windows.</p>

<p>Other applications treat each text widget as a separate action stream. Web browsers behave this way. Try visiting a form in a web browser, and type something into two different fields. You’ll find that Undo only affects the field with the current keyboard focus, ignoring actions you made on any other fields. Changes made in other kinds of form widgets - drop-down menus or listboxes, for example - aren’t added to any action stream.</p>

<p>Applications with multiple simultaneous users - such as a shared network whiteboard, where anybody can scribble on it - face the question of whether Undo should affect only your own actions, or everybody’s actions.
Usually, the best answer to this question is only your own actions, unless you have some kind of floor control mechanism that prevents people from working simultaneously.  (See Abowd &amp; Dix, “<a href="http://alandix.com/academic/papers/undo92/undo.pdf">Giving undo attention</a>,”
Interacting with Computers, v4 n3, 1992).</p></div><div class="row"><div class="slide col-sm-6"><div class="slideTitle"><p>How is the stream divided into units?</p></div>
<ul><li><p>Lexical Level</p></li>
<ul><li><p>Mouse clicks, key presses, mouse moves</p></li>
<li><p>Nobody does it at this level</p></li></ul>
<li><p>Syntactic level</p></li>
<ul><li><p>Commands and button presses</p></li></ul>
<li><p>Semantic level</p></li>
<ul><li><p>Changes to application data structures (e.g. the result of an entire Format dialog</p></li>
<li><p>This is the normal level</p></li></ul>
<li><p>Text entry is aggregated into a single action</p></li>
<ul><li><p>But other editing commands (like Backspace) and newlines interrupt the aggregation</p></li></ul>
<li><p>What about user-defined macros?</p></li>
<ul><li><p>Undo macro actions individually, or as a unit?</p></li></ul></ul></div>

<p>Once you’ve decided which stream of actions to undo, the next question is, how is the stream divided into units? This is important because Undo reverses the last unit action of the stream.</p>

<p>Dividing at the <strong>lexical level</strong> means low-level input events, so Undo might reverse the very last keyboard or mouse change. For example, if you just did a drag-and-drop, invoking Undo might undo your mouse button release, putting you back into drag-and-drop mode and allowing you to drop somewhere else. No user interface (that I know of) implements lexical Undo in a systematic way; it’s not clear how to get it right (since you’re not holding the button down anymore!), and it’s probably not what users want.</p>

<p>At the <strong>syntactic level</strong>, you would undo commands or onscreen button presses. For menu items and toolbar buttons, this is the right thing. But if you just finished a dialog - say, using the Font dialog, or selecting a Color - then this would undo the OK button press, returning you into the dialog box. Most applications don’t do it at this level either.</p>

<p>The <strong>semantic level</strong> is what most designers choose, where Undo reverses the most recent change to the backend model - whether it was caused by a simple command, like Boldface, or a complicated dialog, like Page Layout. That’s great for one kind of user control and freedom, since it makes complex changes just as easy to back out of as simple changes. But what if you just completed a long wizard dialog, only to discover that it didn’t do what you wanted, and Undo only reverses the effect of the entire dialog, instead of getting you back into the wizard and letting you Back up? There are tradeoffs in the decision to undo only at the semantic level, but it’s the most common.</p>

<p>For undoing text, individual typed characters should be <strong>aggregated</strong> somehow - otherwise, Undo won’t be any faster than pressing Backspace. One natural way to do this might be word boundaries; but most text editors use edit commands and newlines as boundaries.</p>

<p>In general, the action stream should be divided into <strong>chunks</strong> from the user’s perspective. For example, a user-defined macro is a chunk, so Undo should treat the entire macro as a unit action.</p></div><div class="row"><div class="slide col-sm-6"><div class="slideTitle"><p>Which actions are undoable?</p></div>
<ul><li><p>User’s action stream may include many actions that are ignored by Undo</p></li>
<ul><li><p>Selection</p></li>
<li><p>Keyboard focus</p></li>
<li><p>Changing viewpoint (scrolling, zooming)</p></li>
<li><p>Changing layout (opening palettes or sidebars, adjusting window sizes)</p></li>
<li><p>UI customization (adding buttons to toolbars)</p></li></ul>
<li><p>So which actions does Undo actually undo?</p></li>
<ul><li><p>Some applications (web browsers, IDEs) have Undo/Redo for the editing stream, Back/Forward for the viewport stream</p></li></ul></ul></div>

<p>Many actions that affect visible program state may be completely ignored by Undo. Typically these actions affect the view, but don’t actually change the backend model. Examples include selection, keyboard focus, scrolling and zooming, window management, and user interface customizations.</p>

<p>Since easy reversibility can be just as helpful for view changes, some applications define new commands for them, so they can reserve Undo for reversing model changes. Web browsers are a fine example: the Back button reverses a jump in view (whether caused by loading a new page or clicking on an internal hyperlink to jump to another place in the same page). Development environments like Eclipse have borrowed this idiom for navigation in code editors; you can press Back to undo window switching and scrolling.</p></div><div class="row"><div class="slide col-sm-6"><div class="slideTitle"><p>How much state is recovered?</p></div>
<ul><li><p>Select text, delete it, and then undo</p></li>
<ul><li><p>Text is restored</p></li>
<li><p>But is selection restored? What about cursor position?</p></li></ul></ul></div>

<p>Even if the Undo stream doesn’t include all the view changes you make, how much of the view state will be restored when it reverses a model change? When you undo a text edit, for example, will the selection highlight be restored as well? Will the text cursor be put back where it was before the edit? If the text scrolls, will it be scrolled back to the same place?</p></div><div class="row"><div class="slide col-sm-6"><div class="slideTitle"><p>How far back can you undo?</p></div>
<ul><li><p>Often a limit on history size</p></li>
<ul><li><p>Used to be one action - now usually hundreds, or infinite!</p></li></ul>
<li><p>Does action stream persist across application sessions?</p></li>
<ul><li><p>If so, stream must be saved to file</p></li></ul>
<li><p>Does it persist across File/Save?</p></li></ul></div>

<p>Finally, how far back will the undo history stream go? Old Macintosh applications had only single undo - i.e., you could only undo the last action, and no farther. Thankfully, cheap memory has made deep undo history feasible and commonplace.
Even though memory no longer limits undo, the conventional model of undo still does. In most applications,</p>

<p>Undo is a transient phenomenon, limited to a single application session. If you shut down the application, and then restart it, the undo history is erased. So you can’t undo past the start of the current session.</p>

<p>Some applications even erase the undo history as soon as the user saves a document to disk. Older versions of Microsoft Office used to behave this way.</p></div><div class="row"><div class="slide col-sm-6"><div class="slideTitle"><p>Curious Case Study: Outlook Sticky Notes</p></div>
<img src="figures/16.png"></div>

<p>Try this in Outlook 2007 (or Outlook 2003, but doesn’t work in Outlook Express). Create a sticky note (File/ New/Note). Type some text into the note, and move the note to a different place on the screen. Then press Ctrl-Z to undo. It undoes not only what you typed, but also the position of the note - and the note animates through all the different positions you moved it to on the screen.</p>

<p>Recall the important dimensions of an undo model:</p>

<ul>
<li>what stream of actions is undone? Only the actions that affected this sticky note; other sticky notes, and other Outlook windows, aren’t affected.</li>
<li>how is the stream divided into units? It turns out that the entire stream of actions since the note was created is a single unit - everything gets undone when you press Ctrl-Z once.</li>
<li>what state is actually restored? everything about the note - its position, its size, even its color.</li>
<li>how far back can you undo? As far as the creation of the note - unless you switch to another window.</li>
</ul>

<p>Switching away from the note clears the note’s undo history, so further undo is impossible.</p>

<p>What else is wrong here? As the screenshot shows, the animation wasn’t even done properly - instead of animating using automatic redraw, Outlook paints the moving note directly on the screen, leaving a smear behind it. Notice that the smear is visible in some parts of the Outlook window, but not in others. Why do you think that is?</p></div><div class="row"><div class="slide col-sm-6"><div class="slideTitle"><p>Design Principles for Undo</p></div>
<ul><li><p>Visibility</p></li>
<li><p>Aggregation</p></li>
<li><p>Reversibility of the Undo itself</p></li>
<li><p>Reserve it for model changes, not view changes</p></li>
<li><p>Undo is not the only way to support reversibility</p></li></ul></div>

<p>The upshot of all these questions is that it’s very hard for users to predict what Undo will do. Faced with this unpredictability, a common strategy is to press Undo until you see the effect you want to reverse actually go away, or until you realize it’s gone too far without solving the problem (i.e., it’s reversed an older, still-desired effect). So visibility of Undo’s effects is a critical part of making it usable. Whenever Undo undoes a command, it should make sure that the effects of that have a visible change on the screen. If the user has changed the viewpoint (e.g. scrolling) since doing the command that is now being undone, the viewpoint should be changed back, so that it’s easy to see what was reversed.</p>

<p>The unit actions should correspond to chunks of the user’s interaction: whole typed words (or strings), complete dialogs, user-defined macros.</p>

<p>Undo itself should be reversible, so that if you overshoot, you can come back. That’s what the Redo command is for. Another way to reverse an Undo is to manually issue the undone command again; a good undo mechanism should set up the conditions for this as well.</p>

<p>For example, suppose you select a range of text and
Delete it, and then Undo that deletion. The editor should not only restore the text, but also restore the selection highlight, so that you can immediately press Delete to delete the same text again.</p>

<p>For consistency, reserve the Undo command for model changes. You can use other commands for view changes. Keep in mind that you don’t necessarily need a command named “Undo” to support reversibility.</p>

<p>There are other commands that move through other action streams (Back), and physical manipulations (like scrollbar dragging) support direct reversibility.
Users may not even think of reaching for Undo if the rest of your interface makes it easy to reverse undesired changes. Undo is a form of backward error recovery, which fixes errors by going back in time. A more natural way of thinking is forward error recovery - using other commands to reverse the change. For example, to undo a Bold command by forward error recovery, you select the text again and toggle Bold off. If your interface supports forward error recovery as much as possible, then warts in the Undo model won’t hurt as much.</p>

<div class="reading-exercises exercises panel-group converted" id="ex_5"><h4 class="text-danger">reading exercises</h4>

<div class="panel panel-danger"><div class="panel-heading" data-target="#ex_5-exercise" data-toggle-no="collapse"><span class="panel-title">Exercise (Self Study)</span></div><div class="panel-collapse kkkcollapse exercise-panel" id="ex_5-exercise" data-outline="exercise" data-ex-id="undo/exercise" data-ex-category="reading-exercises" data-ex-remote="https://rcm.scripts.mit.edu/handx/sp18/submit.php" data-ex-handout="classes-04-safety"><div class="panel-body"><img src="figures/gmail-undo.png" width="600"><p>Consider the undo UI above.  Which of the following are represented in this example? (choose all good answers)</p><div class="form-group exercise-part" data-outline="a"><div class="checkbox exercise-choice" data-outline="single-level undo"><label for="md_converted_choice_5_0"><input type="checkbox" id="md_converted_choice_5_0">single-level undo</label><span class="exercise-answer exercise-remote" style="display: none;">(missing answer)</span></div>
<div class="checkbox exercise-choice" data-outline="undoing a backend model change"><label for="md_converted_choice_5_1"><input type="checkbox" id="md_converted_choice_5_1">undoing a backend model change</label><span class="exercise-answer exercise-remote" style="display: none;">(missing answer)</span></div>
<div class="checkbox exercise-choice" data-outline="aggregation"><label for="md_converted_choice_5_2"><input type="checkbox" id="md_converted_choice_5_2">aggregation</label><span class="exercise-answer exercise-remote" style="display: none;">(missing answer)</span></div>
<div class="checkbox exercise-choice" data-outline="undoing a UI view change"><label for="md_converted_choice_5_3"><input type="checkbox" id="md_converted_choice_5_3">undoing a UI view change</label><span class="exercise-answer exercise-remote" style="display: none;">(missing answer)</span></div>
</div><div class="exercise-explain exercise-remote"><p>(missing explanation)</p></div><div class="form-inline"><div class="form-group"><button class="btn hidden btn-default exercise-submit">check</button> <button class="btn btn-default exercise-reveal" style="display: none;">explain</button></div><div class="exercise-progress progress"><div class="progress-bar progress-bar-danger progress-bar-striped active"></div></div><div class="exercise-error"></div></div></div></div></div>





</div></div></div>















</div></div></main>
<footer class="col-sm-2 footer-margin"><div>Collaboratively authored with contributions from: Elena Glassman, Philip Guo, Daniel Jackson, David Karger, Juho Kim, Rob Miller, Stefanie Mueller, Clayton Sims, and Haoqi Zhang. This work is licensed under <a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/">CC&nbsp;BY-SA&nbsp;4.0</a>.</div><div>Revised for SPU CSC3220 Applications Programming course use by Taiwoo Park. This work is licensed under <a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/">CC&nbsp;BY-SA&nbsp;4.0</a>.</div></footer>
<script charset="utf-8" src="../../web/jquery.min.js"></script>


<script charset="utf-8" src="../../web/bootstrap.min.js"></script><footer>SPU ECS</footer><script charset="utf-8" src="../../web/handout-run.js"></script></body>
<!-- Mirrored from web.mit.edu/6.813/www/sp18/classes/04-safety/ by HTTrack Website Copier/3.x [XR&CO'2014], Thu, 19 Dec 2019 21:53:05 GMT -->
</html><!-- Handout delivered Mon Feb 12 2018 02:01:49 GMT-0500 (EST) -->